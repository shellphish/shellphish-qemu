diff --git a/linux-user/main.c b/linux-user/main.c
index 24d1eb7..7bb4a30 100644
--- a/linux-user/main.c
+++ b/linux-user/main.c
@@ -269,6 +269,11 @@ static void handle_arg_unset_env(const char *arg)
     free(r);
 }
 
+static void handle_arg_mmap_start(const char *arg)
+{
+    qemu_set_mmap_start(arg);
+}
+
 static void handle_arg_argv0(const char *arg)
 {
     argv0 = strdup(arg);
@@ -417,6 +422,8 @@ struct qemu_argument {
 };
 
 static const struct qemu_argument arg_table[] = {
+    {"S",          "MMAP_START",       true,  handle_arg_mmap_start,
+     "mmap_start", "mmap base for the guest program"},
     {"h",          "",                 false, handle_arg_help,
      "",           "print this help"},
     {"help",       "",                 false, handle_arg_help,
diff --git a/linux-user/mmap.c b/linux-user/mmap.c
index 00c05e6..529dc43 100644
--- a/linux-user/mmap.c
+++ b/linux-user/mmap.c
@@ -246,6 +246,19 @@ static int mmap_frag(abi_ulong real_start,
 #endif
 abi_ulong mmap_next_start = TASK_UNMAPPED_BASE;
 
+void qemu_set_mmap_start(const char *arg)
+{
+    int ret = sscanf(arg, "0x" TARGET_FMT_lx, &mmap_next_start);
+    if (ret != 1) {
+        fprintf(stderr, "Fail to parse mmap_start: '%s', expect 0xXXXXXXXX\n", arg);
+        exit(1);
+    }
+   if ((mmap_next_start & 0xfff) != 0) {
+        fprintf(stderr, "mmap_start: '%s' is not page-alignd\n", arg);
+        exit(1);
+   }
+}
+
 unsigned long last_brk;
 
 /* Subroutine of mmap_find_vma, used when we have pre-allocated a chunk
diff --git a/linux-user/qemu.h b/linux-user/qemu.h
index 534753c..1a71a7f 100644
--- a/linux-user/qemu.h
+++ b/linux-user/qemu.h
@@ -221,6 +221,7 @@ int loader_exec(int fdexec, const char *filename, char **argv, char **envp,
  * when handling signals.
  */
 int info_is_fdpic(struct image_info *info);
+void qemu_set_mmap_start(const char *args);
 
 uint32_t get_elf_eflags(int fd);
 int load_elf_binary(struct linux_binprm *bprm, struct image_info *info);
