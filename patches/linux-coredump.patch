diff --git a/accel/tcg/cpu-exec.c b/accel/tcg/cpu-exec.c
index d95c484..5ffb1b0 100644
--- a/accel/tcg/cpu-exec.c
+++ b/accel/tcg/cpu-exec.c
@@ -138,6 +138,30 @@ static void init_delay_params(SyncClocks *sc, const CPUState *cpu)
 #endif /* CONFIG USER ONLY */
 
 /* Execute a TB, and fix up the CPU state afterwards if necessary */
+abi_long core_addr = 0;
+abi_long core_dumped = 0;
+void qemu_set_core_addr(const char *addr_str)
+{
+    int ret = sscanf(addr_str, "0x" TARGET_FMT_lx, &core_addr);
+    if(ret != 1) {
+        fprintf(stderr, "Fail to parse coreaddr: '%s'\n", addr_str);
+        exit(1);
+    }
+}
+
+abi_long trace_start_addr = 0;
+static int trace_started = 1;
+void qemu_set_trace_start_addr(const char *addr_str)
+{
+    int ret = sscanf(addr_str, "0x" TARGET_FMT_lx, &trace_start_addr);
+    if(ret != 1) {
+        fprintf(stderr, "Fail to parse trace_start_addr: '%s'\n", addr_str);
+        exit(1);
+    }
+    trace_started = 0;
+}
+
+extern int elf_core_dump(int signr, const CPUArchState *env);
 static inline tcg_target_ulong cpu_tb_exec(CPUState *cpu, TranslationBlock *itb)
 {
     CPUArchState *env = cpu->env_ptr;
@@ -146,12 +170,25 @@ static inline tcg_target_ulong cpu_tb_exec(CPUState *cpu, TranslationBlock *itb)
     int tb_exit;
     uint8_t *tb_ptr = itb->tc.ptr;
 
-    qemu_log_mask_and_addr(CPU_LOG_EXEC, itb->pc,
-                           "Trace %d: %p ["
-                           TARGET_FMT_lx "/" TARGET_FMT_lx "/%#x] %s\n",
-                           cpu->cpu_index, itb->tc.ptr,
-                           itb->cs_base, itb->pc, itb->flags,
-                           lookup_symbol(itb->pc));
+    // decide whether to start tracing
+    if(unlikely(trace_start_addr != 0 && trace_started == 0)) {
+        if(unlikely(trace_start_addr >= itb->pc && trace_start_addr < itb->pc + itb->size)) trace_started = 1;
+    }
+
+    if(trace_started) {
+        qemu_log_mask_and_addr(CPU_LOG_EXEC, itb->pc,
+                               "Trace %d: %p ["
+                               TARGET_FMT_lx "/" TARGET_FMT_lx "/%#x] %s\n",
+                               cpu->cpu_index, itb->tc.ptr,
+                               itb->cs_base, itb->pc, itb->flags,
+                               lookup_symbol(itb->pc));
+    }
+
+    if(unlikely(core_dumped == 0 && core_addr >= itb->pc && core_addr < itb->pc + itb->size)) {
+        elf_core_dump(SIGSEGV, env);
+        core_dumped = 1;
+        sleep(2);// sleep 2 seconds for qemu to not overwrite the previous coredump
+    }
 
 #if defined(DEBUG_DISAS)
     if (qemu_loglevel_mask(CPU_LOG_TB_CPU)
diff --git a/include/elf.h b/include/elf.h
index 8fbfe60..79e5fbc 100644
--- a/include/elf.h
+++ b/include/elf.h
@@ -1634,6 +1634,7 @@ typedef struct elf64_shdr {
 #define NT_TASKSTRUCT	4
 #define NT_AUXV		6
 #define NT_PRXFPREG     0x46e62b7f      /* copied from gdb5.1/include/elf/common.h */
+#define NT_FILE     0x46494c45          /* copied from gdb5.1/include/elf/common.h */
 #define NT_S390_GS_CB   0x30b           /* s390 guarded storage registers */
 #define NT_S390_VXRS_HIGH 0x30a         /* s390 vector registers 16-31 */
 #define NT_S390_VXRS_LOW  0x309         /* s390 vector registers 0-15 (lower half) */
diff --git a/include/exec/log.h b/include/exec/log.h
index fcc7b9e..767c6d0 100644
--- a/include/exec/log.h
+++ b/include/exec/log.h
@@ -13,6 +13,10 @@
  *
  * Logs the output of cpu_dump_state().
  */
+
+void qemu_set_core_addr(const char *addr_str);
+void qemu_set_trace_start_addr(const char *addr_str);
+
 static inline void log_cpu_state(CPUState *cpu, int flags)
 {
     QemuLogFile *logfile;
diff --git a/linux-user/elfload.c b/linux-user/elfload.c
index 8198be0..ff764ab 100644
--- a/linux-user/elfload.c
+++ b/linux-user/elfload.c
@@ -1,6 +1,8 @@
 /* This is the Linux kernel elf-loading code, ported into user space */
 #include "qemu/osdep.h"
 #include <sys/param.h>
+#include <sys/types.h>
+#include <sys/stat.h>
 
 #include <sys/resource.h>
 #include <sys/shm.h>
@@ -1659,7 +1661,7 @@ static inline void bswap_mips_abiflags(Mips_elf_abiflags_v0 *abiflags) { }
 #endif
 
 #ifdef USE_ELF_CORE_DUMP
-static int elf_core_dump(int, const CPUArchState *);
+int elf_core_dump(int, const CPUArchState *);
 #endif /* USE_ELF_CORE_DUMP */
 static void load_symbols(struct elfhdr *hdr, int fd, abi_ulong load_bias);
 
@@ -2999,6 +3001,13 @@ struct target_elf_prpsinfo {
     char    pr_psargs[ELF_PRARGSZ]; /* initial part of arg list */
 };
 
+struct target_ntfile_entry {
+    abi_ulong   vm_start;
+    abi_ulong   vm_end;
+    abi_ulong   page_offset;
+    char        *path;
+};
+
 /* Here is the structure in which status of each thread is captured. */
 struct elf_thread_status {
     QTAILQ_ENTRY(elf_thread_status)  ets_link;
@@ -3357,6 +3366,118 @@ static void fill_auxv_note(struct memelfnote *note, const TaskState *ts)
     }
 }
 
+static void fill_ntfile_note(struct memelfnote *note, TaskState *ts)
+{
+    FILE *fp;
+    char *line = NULL;
+    size_t len = 0;
+    ssize_t read;
+    int count = 0;
+    int data_size = sizeof(abi_long)*2; // reserve space for num_map_entry and page_size
+    struct target_ntfile_entry *entries = NULL;
+
+    fp = fopen("/proc/self/maps", "r");
+    if (fp == NULL) {
+        return;
+    }
+
+    // grab memory mapping first
+    while ((read = getline(&line, &len, fp)) != -1) {
+        int fields, dev_maj, dev_min, inode;
+        uint64_t min, max, offset;
+        char flag_r, flag_w, flag_x, flag_p;
+        char path[512] = "";
+        fields = sscanf(line, "%"PRIx64"-%"PRIx64" %c%c%c%c %"PRIx64" %x:%x %d"
+                        " %512s", &min, &max, &flag_r, &flag_w, &flag_x,
+                        &flag_p, &offset, &dev_maj, &dev_min, &inode, path);
+
+        if ((fields < 10) || (fields > 11)) {
+            continue;
+        }
+        if (h2g_valid(min)) {
+            int flags = page_get_flags(h2g(min));
+            max = h2g_valid(max - 1) ? max : (uintptr_t)g2h(GUEST_ADDR_MAX) + 1;
+            if (page_check_range(h2g(min), max - min, flags) == -1) {
+                continue;
+            }
+            if (h2g(min) == ts->info->stack_limit) {
+                strcpy(path, "      [stack]");
+            }
+            // NT_FILE requires the mapping to be backed by a file
+            if (access(path, F_OK) != 0) continue;
+
+            count++;
+            entries = realloc(entries, sizeof(struct target_ntfile_entry)*count);
+            struct target_ntfile_entry *entry = &entries[count-1];
+            memset(entry, 0, sizeof(*entry));
+
+            data_size += sizeof(abi_long)*3 + strlen(path) + 1;
+            entry->vm_start = h2g(min);
+            entry->vm_end = h2g(max - 1) + 1;
+            entry->page_offset = offset / TARGET_PAGE_SIZE;
+            entry->path = strdup(path);
+        }
+    }
+
+    // prepare the memory mapping in NT_FILE format
+    char *ptr;
+    int idx = 0;
+    ptr = (char *)g_malloc0(data_size);
+    abi_long *long_ptr = (abi_long *)ptr;
+
+    // memory mappings
+#ifdef BSWAP_NEEDED
+    long_ptr[idx++] = tswapl(count);    // number of map entries
+    long_ptr[idx++] = tswapl(TARGET_PAGE_SIZE);   // target page size
+    for(int i=0; i<count; i++) {
+        struct target_ntfile_entry *entry = &entries[i];
+        long_ptr[idx++] = tswapl(entry->vm_start);
+        long_ptr[idx++] = tswapl(entry->vm_end);
+        long_ptr[idx++] = tswapl(entry->page_offset);
+    }
+#else
+    long_ptr[idx++] = count;    // number of map entries
+    long_ptr[idx++] = TARGET_PAGE_SIZE;   // target page size
+    for(int i=0; i<count; i++) {
+        struct target_ntfile_entry *entry = &entries[i];
+        long_ptr[idx++] = entry->vm_start;
+        long_ptr[idx++] = entry->vm_end;
+        long_ptr[idx++] = entry->page_offset;
+    }
+#endif
+
+    // path names
+    idx *= sizeof(abi_long);
+    for(int i=0; i<count; i++) {
+        struct target_ntfile_entry *entry = &entries[i];
+        int path_size = strlen(entry->path);
+        strcpy(&ptr[idx], entry->path);
+        idx += path_size + 1;
+        free(entry->path);
+    }
+
+    // write it out
+    fill_note(note, "CORE", NT_FILE, data_size, ptr);
+
+    // cleanup
+    free(entries);
+    free(line);
+    fclose(fp);
+}
+
+const char *coredump_prefix = ".";
+void qemu_set_core_dump_prefix(const char *prefix)
+{
+    struct stat path_stat;
+    char* path = NULL;
+
+    if (stat(prefix, &path_stat) != 0) return;
+    if (!S_ISDIR(path_stat.st_mode)) return;
+
+    path = (char *)malloc(PATH_MAX+1);
+    coredump_prefix = realpath(prefix, path);
+}
+
 /*
  * Constructs name of coredump file.  We have following convention
  * for the name:
@@ -3383,7 +3504,7 @@ static int core_dump_filename(const TaskState *ts, char *buf,
     base_filename = g_path_get_basename(ts->bprm->filename);
     (void) strftime(timestamp, sizeof (timestamp), "%Y%m%d-%H%M%S",
                     localtime_r(&tv.tv_sec, &tm));
-    (void) snprintf(buf, bufsize, "qemu_%s_%s_%d.core",
+    (void) snprintf(buf, bufsize, "%s/qemu_%s_%s_%d.core", coredump_prefix,
                     base_filename, timestamp, (int)getpid());
     g_free(base_filename);
 
@@ -3487,7 +3608,7 @@ static void init_note_info(struct elf_note_info *info)
 static int fill_note_info(struct elf_note_info *info,
                           long signr, const CPUArchState *env)
 {
-#define NUMNOTES 3
+#define NUMNOTES 4
     CPUState *cpu = env_cpu((CPUArchState *)env);
     TaskState *ts = (TaskState *)cpu->opaque;
     int i;
@@ -3504,7 +3625,7 @@ static int fill_note_info(struct elf_note_info *info,
 
     /*
      * First fill in status (and registers) of current thread
-     * including process info & aux vector.
+     * including process info, aux vector & memory mapping.
      */
     fill_prstatus(info->prstatus, ts, signr);
     elf_core_copy_regs(&info->prstatus->pr_reg, env);
@@ -3514,7 +3635,8 @@ static int fill_note_info(struct elf_note_info *info,
     fill_note(&info->notes[1], "CORE", NT_PRPSINFO,
               sizeof (*info->psinfo), info->psinfo);
     fill_auxv_note(&info->notes[2], ts);
-    info->numnote = 3;
+    fill_ntfile_note(&info->notes[3], ts);
+    info->numnote = NUMNOTES;
 
     info->notes_size = 0;
     for (i = 0; i < info->numnote; i++)
@@ -3610,7 +3732,7 @@ static int write_note_info(struct elf_note_info *info, int fd)
  * handler (provided that target process haven't registered
  * handler for that) that does the dump when signal is received.
  */
-static int elf_core_dump(int signr, const CPUArchState *env)
+int elf_core_dump(int signr, const CPUArchState *env)
 {
     const CPUState *cpu = env_cpu((CPUArchState *)env);
     const TaskState *ts = (const TaskState *)cpu->opaque;
diff --git a/linux-user/main.c b/linux-user/main.c
index 22578b1..de746bd 100644
--- a/linux-user/main.c
+++ b/linux-user/main.c
@@ -288,6 +288,21 @@ static void handle_arg_stack_size(const char *arg)
     }
 }
 
+static void handle_arg_core(const char *arg)
+{
+    qemu_set_core_dump_prefix(arg);
+}
+
+static void handle_arg_core_addr(const char *arg)
+{
+    qemu_set_core_addr(arg);
+}
+
+static void handle_arg_trace_start_addr(const char *arg)
+{
+    qemu_set_trace_start_addr(arg);
+}
+
 static void handle_arg_ld_prefix(const char *arg)
 {
     interp_prefix = strdup(arg);
@@ -424,6 +439,12 @@ static const struct qemu_argument arg_table[] = {
      "",           ""},
     {"g",          "QEMU_GDB",         true,  handle_arg_gdb,
      "port",       "wait gdb connection to 'port'"},
+    {"C",          "QEMU_CORE_PREFIX", true,  handle_arg_core,
+     "path",       "set coredump path prefix to 'path' (default '.')"},
+    {"A",          "QEMU_CORE_ADDR",   true,  handle_arg_core_addr,
+     "coreaddr",   "generate a core dump at 'coreaddr'"},
+    {"T",          "QEMU_TRACE_START_ADDR",   true,  handle_arg_trace_start_addr,
+     "tracestart", "start tracing after tracestart address"},
     {"L",          "QEMU_LD_PREFIX",   true,  handle_arg_ld_prefix,
      "path",       "set the elf interpreter prefix to 'path'"},
     {"s",          "QEMU_STACK_SIZE",  true,  handle_arg_stack_size,
diff --git a/linux-user/qemu.h b/linux-user/qemu.h
index 792c742..f59c86d 100644
--- a/linux-user/qemu.h
+++ b/linux-user/qemu.h
@@ -201,6 +201,7 @@ int info_is_fdpic(struct image_info *info);
 uint32_t get_elf_eflags(int fd);
 int load_elf_binary(struct linux_binprm *bprm, struct image_info *info);
 int load_flt_binary(struct linux_binprm *bprm, struct image_info *info);
+void qemu_set_core_dump_prefix(const char *prefix);
 
 abi_long memcpy_to_target(abi_ulong dest, const void *src,
                           unsigned long len);
diff --git a/linux-user/signal.c b/linux-user/signal.c
index 8cf51ff..8e3ae55 100644
--- a/linux-user/signal.c
+++ b/linux-user/signal.c
@@ -619,14 +619,17 @@ void force_sigsegv(int oldsig)
 
 #endif
 
+void QEMU_NORETURN dump_core_and_abort(int target_sig);
 /* abort execution with signal */
-static void QEMU_NORETURN dump_core_and_abort(int target_sig)
+void QEMU_NORETURN dump_core_and_abort(int target_sig)
 {
     CPUState *cpu = thread_cpu;
     CPUArchState *env = cpu->env_ptr;
     TaskState *ts = (TaskState *)cpu->opaque;
     int host_sig, core_dumped = 0;
     struct sigaction act;
+    target_ulong cs_base, pc;
+    uint32_t flags;
 
     host_sig = target_to_host_signal(target_sig);
     trace_user_force_sig(env, target_sig, host_sig);
@@ -649,6 +652,11 @@ static void QEMU_NORETURN dump_core_and_abort(int target_sig)
             target_sig, strsignal(host_sig), "core dumped" );
     }
 
+    cpu_get_tb_cpu_state(env, &pc, &cs_base, &flags);
+    qemu_log("qemu: uncaught target signal %d (%s) - %s [%0*llx]\n",
+             target_sig, strsignal(host_sig), "core dumped",
+             (int)sizeof(target_ulong)*2, (unsigned long long)pc);
+
     /* The proper exit code for dying from an uncaught signal is
      * -<signal>.  The kernel doesn't allow exit() or _exit() to pass
      * a negative value.  To get the proper exit code we need to
diff --git a/target/mips/translate.c b/target/mips/translate.c
index 25b595a..f9db3cd 100644
--- a/target/mips/translate.c
+++ b/target/mips/translate.c
@@ -30942,9 +30942,9 @@ static void mips_tr_translate_insn(DisasContextBase *dcbase, CPUState *cs)
         (ctx->hflags & MIPS_HFLAG_BMASK) == 0) {
         ctx->base.is_jmp = DISAS_TOO_MANY;
     }
-    if (ctx->base.pc_next - ctx->page_start >= TARGET_PAGE_SIZE) {
-        ctx->base.is_jmp = DISAS_TOO_MANY;
-    }
+//    if (ctx->base.pc_next - ctx->page_start >= TARGET_PAGE_SIZE) {
+//        ctx->base.is_jmp = DISAS_TOO_MANY;
+//    }
 }
 
 static void mips_tr_tb_stop(DisasContextBase *dcbase, CPUState *cs)
