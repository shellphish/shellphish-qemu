diff --git a/include/elf.h b/include/elf.h
index 8fbfe60..79e5fbc 100644
--- a/include/elf.h
+++ b/include/elf.h
@@ -1634,6 +1634,7 @@ typedef struct elf64_shdr {
 #define NT_TASKSTRUCT	4
 #define NT_AUXV		6
 #define NT_PRXFPREG     0x46e62b7f      /* copied from gdb5.1/include/elf/common.h */
+#define NT_FILE     0x46494c45          /* copied from gdb5.1/include/elf/common.h */
 #define NT_S390_GS_CB   0x30b           /* s390 guarded storage registers */
 #define NT_S390_VXRS_HIGH 0x30a         /* s390 vector registers 16-31 */
 #define NT_S390_VXRS_LOW  0x309         /* s390 vector registers 0-15 (lower half) */
diff --git a/linux-user/elfload.c b/linux-user/elfload.c
index 8198be0..71601c9 100644
--- a/linux-user/elfload.c
+++ b/linux-user/elfload.c
@@ -1,6 +1,8 @@
 /* This is the Linux kernel elf-loading code, ported into user space */
 #include "qemu/osdep.h"
 #include <sys/param.h>
+#include <sys/types.h>
+#include <sys/stat.h>
 
 #include <sys/resource.h>
 #include <sys/shm.h>
@@ -2999,6 +3001,13 @@ struct target_elf_prpsinfo {
     char    pr_psargs[ELF_PRARGSZ]; /* initial part of arg list */
 };
 
+struct target_ntfile_entry {
+    abi_ulong   vm_start;
+    abi_ulong   vm_end;
+    abi_ulong   page_offset;
+    char        *path;
+};
+
 /* Here is the structure in which status of each thread is captured. */
 struct elf_thread_status {
     QTAILQ_ENTRY(elf_thread_status)  ets_link;
@@ -3193,21 +3202,21 @@ static abi_ulong vma_dump_size(const struct vm_area_struct *vma)
      * and check whether it contains elf header.  If there is
      * no elf header, we dump it.
      */
-    if (vma->vma_flags & PROT_EXEC) {
-        char page[TARGET_PAGE_SIZE];
-
-        copy_from_user(page, vma->vma_start, sizeof (page));
-        if ((page[EI_MAG0] == ELFMAG0) &&
-            (page[EI_MAG1] == ELFMAG1) &&
-            (page[EI_MAG2] == ELFMAG2) &&
-            (page[EI_MAG3] == ELFMAG3)) {
-            /*
-             * Mappings are possibly from ELF binary.  Don't dump
-             * them.
-             */
-            return (0);
-        }
-    }
+    // if (vma->vma_flags & PROT_EXEC) {
+    //     char page[TARGET_PAGE_SIZE];
+
+    //     copy_from_user(page, vma->vma_start, sizeof (page));
+    //     if ((page[EI_MAG0] == ELFMAG0) &&
+    //         (page[EI_MAG1] == ELFMAG1) &&
+    //         (page[EI_MAG2] == ELFMAG2) &&
+    //         (page[EI_MAG3] == ELFMAG3)) {
+    //         /*
+    //          * Mappings are possibly from ELF binary.  Don't dump
+    //          * them.
+    //          */
+    //         return (0);
+    //     }
+    // }
 
     return (vma->vma_end - vma->vma_start);
 }
@@ -3357,6 +3366,97 @@ static void fill_auxv_note(struct memelfnote *note, const TaskState *ts)
     }
 }
 
+static void fill_ntfile_note(struct memelfnote *note, TaskState *ts)
+{
+    GSList *map_info = read_self_maps();
+    GSList *s;
+    int count = 0;
+    int data_size = sizeof(abi_long)*2; // reserve space for num_map_entry and page_size
+    struct target_ntfile_entry *entries = NULL;
+
+    // grab memory mapping first
+    for (s = map_info; s; s = g_slist_next(s)) {
+        MapInfo *e = (MapInfo *) s->data;
+
+        if (h2g_valid(e->start)) {
+            unsigned long min = e->start;
+            unsigned long max = e->end;
+            int flags = page_get_flags(h2g(min));
+            const char *path;
+
+            max = h2g_valid(max - 1) ?
+                max : (uintptr_t) g2h(GUEST_ADDR_MAX) + 1;
+
+            if (page_check_range(h2g(min), max - min, flags) == -1) {
+                continue;
+            }
+
+            if (h2g(min) == ts->info->stack_limit) {
+                path = "[stack]";
+            } else {
+                path = e->path;
+            }
+
+            count++;
+            entries = realloc(entries, sizeof(struct target_ntfile_entry)*count);
+            struct target_ntfile_entry *entry = &entries[count-1];
+            memset(entry, 0, sizeof(*entry));
+
+            data_size += sizeof(abi_long)*3 + strlen(path) + 1;
+            entry->vm_start = h2g(min);
+            entry->vm_end = h2g(max - 1) + 1;
+            entry->page_offset = e->offset;
+            entry->path = strdup(path);
+        }
+    }
+
+    // prepare the memory mapping in NT_FILE format
+    char *ptr;
+    int idx = 0;
+    ptr = (char *)g_malloc0(data_size);
+    abi_long *long_ptr = (abi_long *)ptr;
+
+    // memory mappings
+    long_ptr[idx++] = count;    // number of map entries
+    long_ptr[idx++] = TARGET_PAGE_SIZE;   // target page size
+    for(int i=0; i<count; i++) {
+        struct target_ntfile_entry *entry = &entries[i];
+        long_ptr[idx++] = entry->vm_start;
+        long_ptr[idx++] = entry->vm_end;
+        long_ptr[idx++] = entry->page_offset;
+    }
+
+    // path names
+    idx *= sizeof(abi_long);
+    for(int i=0; i<count; i++) {
+        struct target_ntfile_entry *entry = &entries[i];
+        int path_size = strlen(entry->path);
+        strcpy(&ptr[idx], entry->path);
+        idx += path_size + 1;
+        free(entry->path);
+    }
+
+    // write it out
+    fill_note(note, "CORE", NT_FILE, data_size, ptr);
+
+    // cleanup
+    free(entries);
+    free_self_maps(map_info);
+}
+
+const char *coredump_prefix = ".";
+void qemu_set_core_dump_prefix(const char *prefix)
+{
+    struct stat path_stat;
+    char* path = NULL;
+
+    if (stat(prefix, &path_stat) != 0) return;
+    if (!S_ISDIR(path_stat.st_mode)) return;
+
+    path = (char *)malloc(PATH_MAX+1);
+    coredump_prefix = realpath(prefix, path);
+}
+
 /*
  * Constructs name of coredump file.  We have following convention
  * for the name:
@@ -3383,7 +3483,7 @@ static int core_dump_filename(const TaskState *ts, char *buf,
     base_filename = g_path_get_basename(ts->bprm->filename);
     (void) strftime(timestamp, sizeof (timestamp), "%Y%m%d-%H%M%S",
                     localtime_r(&tv.tv_sec, &tm));
-    (void) snprintf(buf, bufsize, "qemu_%s_%s_%d.core",
+    (void) snprintf(buf, bufsize, "%s/qemu_%s_%s_%d.core", coredump_prefix,
                     base_filename, timestamp, (int)getpid());
     g_free(base_filename);
 
@@ -3487,7 +3587,7 @@ static void init_note_info(struct elf_note_info *info)
 static int fill_note_info(struct elf_note_info *info,
                           long signr, const CPUArchState *env)
 {
-#define NUMNOTES 3
+#define NUMNOTES 4
     CPUState *cpu = env_cpu((CPUArchState *)env);
     TaskState *ts = (TaskState *)cpu->opaque;
     int i;
@@ -3504,7 +3604,7 @@ static int fill_note_info(struct elf_note_info *info,
 
     /*
      * First fill in status (and registers) of current thread
-     * including process info & aux vector.
+     * including process info, aux vector & memory mapping.
      */
     fill_prstatus(info->prstatus, ts, signr);
     elf_core_copy_regs(&info->prstatus->pr_reg, env);
@@ -3514,7 +3614,8 @@ static int fill_note_info(struct elf_note_info *info,
     fill_note(&info->notes[1], "CORE", NT_PRPSINFO,
               sizeof (*info->psinfo), info->psinfo);
     fill_auxv_note(&info->notes[2], ts);
-    info->numnote = 3;
+    fill_ntfile_note(&info->notes[3], ts);
+    info->numnote = NUMNOTES;
 
     info->notes_size = 0;
     for (i = 0; i < info->numnote; i++)
diff --git a/linux-user/main.c b/linux-user/main.c
index 22578b1..ee5ca09 100644
--- a/linux-user/main.c
+++ b/linux-user/main.c
@@ -288,6 +288,11 @@ static void handle_arg_stack_size(const char *arg)
     }
 }
 
+static void handle_arg_core(const char *arg)
+{
+    qemu_set_core_dump_prefix(arg);
+}
+
 static void handle_arg_ld_prefix(const char *arg)
 {
     interp_prefix = strdup(arg);
@@ -424,6 +429,8 @@ static const struct qemu_argument arg_table[] = {
      "",           ""},
     {"g",          "QEMU_GDB",         true,  handle_arg_gdb,
      "port",       "wait gdb connection to 'port'"},
+    {"C",          "QEMU_CORE_PREFIX", true,  handle_arg_core,
+     "path",       "set coredump path prefix to 'path' (default '.')"},
     {"L",          "QEMU_LD_PREFIX",   true,  handle_arg_ld_prefix,
      "path",       "set the elf interpreter prefix to 'path'"},
     {"s",          "QEMU_STACK_SIZE",  true,  handle_arg_stack_size,
diff --git a/linux-user/qemu.h b/linux-user/qemu.h
index 792c742..f59c86d 100644
--- a/linux-user/qemu.h
+++ b/linux-user/qemu.h
@@ -201,6 +201,7 @@ int info_is_fdpic(struct image_info *info);
 uint32_t get_elf_eflags(int fd);
 int load_elf_binary(struct linux_binprm *bprm, struct image_info *info);
 int load_flt_binary(struct linux_binprm *bprm, struct image_info *info);
+void qemu_set_core_dump_prefix(const char *prefix);
 
 abi_long memcpy_to_target(abi_ulong dest, const void *src,
                           unsigned long len);
diff --git a/linux-user/signal.c b/linux-user/signal.c
index 8cf51ff..3322d2c 100644
--- a/linux-user/signal.c
+++ b/linux-user/signal.c
@@ -627,6 +627,8 @@ static void QEMU_NORETURN dump_core_and_abort(int target_sig)
     TaskState *ts = (TaskState *)cpu->opaque;
     int host_sig, core_dumped = 0;
     struct sigaction act;
+    target_ulong cs_base, pc;
+    uint32_t flags;
 
     host_sig = target_to_host_signal(target_sig);
     trace_user_force_sig(env, target_sig, host_sig);
@@ -649,6 +651,16 @@ static void QEMU_NORETURN dump_core_and_abort(int target_sig)
             target_sig, strsignal(host_sig), "core dumped" );
     }
 
+    cpu_get_tb_cpu_state(env, &pc, &cs_base, &flags);
+    if (sizeof(target_ulong) == 4) {
+        qemu_log("qemu: uncaught target signal %d (%s) - %s [%08x]\n",
+                 target_sig, strsignal(host_sig), "core dumped", (unsigned int)pc);
+    }
+    else if (sizeof(target_ulong) == 8) {
+        qemu_log("qemu: uncaught target signal %d (%s) - %s [%016llx]\n",
+                 target_sig, strsignal(host_sig), "core dumped", (unsigned long long)pc);
+    }
+
     /* The proper exit code for dying from an uncaught signal is
      * -<signal>.  The kernel doesn't allow exit() or _exit() to pass
      * a negative value.  To get the proper exit code we need to
